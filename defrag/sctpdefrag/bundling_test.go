package sctpdefrag

import (
	"bytes"
	"testing"

	"github.com/google/gopacket"
	"github.com/google/gopacket/bytediff"
	"github.com/google/gopacket/layers"
)

func TestIteratingChunks(t *testing.T) {
	// The test collects all chunks successfully parsed chunks that are bundled
	// together. According to the comments on the testBundleData packet, the chunk
	// types are as follows:
	expected := []gopacket.LayerType{
		layers.LayerTypeSCTPInit,
		layers.LayerTypeSCTPInitAck,
		layers.LayerTypeSCTPCookieEcho,
		layers.LayerTypeSCTPData,
		layers.LayerTypeSCTPCookieAck,
		layers.LayerTypeSCTPSack,
		layers.LayerTypeSCTPData,
		layers.LayerTypeSCTPSack,
		layers.LayerTypeSCTPHeartbeat,
		layers.LayerTypeSCTPHeartbeatAck,
		layers.LayerTypeSCTPShutdown,
		layers.LayerTypeSCTPShutdownAck,
		layers.LayerTypeSCTPShutdownComplete,
		layers.LayerTypeSCTPUnknownChunkType,
	}

	// We collect all chunks because the decoded chunks should serialise back to the
	// original packet data.
	var chunks []gopacket.SerializableLayer
	for i, chunk := range ChunksFrom(testBundleData) {
		t.Logf("Chunk #%v:\n%v", i, gopacket.LayerDump(chunk))
		if i >= len(expected) {
			t.Errorf("Unexpected chunk #%v = %v", i, chunk.LayerType())
			continue
		}
		if chunk.LayerType() == gopacket.LayerTypeDecodeFailure {
			t.Errorf("Failed to decode chunk #%v: %v", i, chunk.(gopacket.ErrorLayer).Error())
			continue
		}
		// We only collect SerializableLayers, so we can serialise them later and compare
		// to the input data.
		chunks = append(chunks, chunk.(gopacket.SerializableLayer))
		if chunk.LayerType() != expected[i] {
			t.Errorf("Chunk #%v = %v, want %v", i, chunk.LayerType(), expected[i])
		}
	}

	// Once we've collected all chunks, we re-serialise into bytes and compare with
	// the source bytes.
	buf := gopacket.NewSerializeBuffer()
	err := gopacket.SerializeLayers(buf, gopacket.SerializeOptions{}, chunks...)
	if err != nil {
		t.Fatalf("SerializeLayers() failed: %v", err)
	}
	if !bytes.Equal(buf.Bytes(), testBundleData) {
		diff := bytediff.Diff(buf.Bytes(), testBundleData)
		t.Errorf("Serialized data differs from input (got->want):\n%v", bytediff.BashOutput.String(diff))
	}
}

func TestBundleContainerDecodesChunks(t *testing.T) {
	var bundle BundleContainer
	if err := bundle.DecodeFromBytes(testBundleData, gopacket.NilDecodeFeedback); err != nil {
		t.Fatalf("DecodeFromBytes() failed: %v", err)
	}

	// The test collects all chunks successfully parsed chunks that are bundled
	// together. According to the comments on the testBundleData packet, the chunk
	// types are as follows:
	expected := []layers.SCTPChunkType{
		layers.SCTPChunkTypeInit,
		layers.SCTPChunkTypeInitAck,
		layers.SCTPChunkTypeCookieEcho,
		layers.SCTPChunkTypeData,
		layers.SCTPChunkTypeCookieAck,
		layers.SCTPChunkTypeSack,
		layers.SCTPChunkTypeData,
		layers.SCTPChunkTypeSack,
		layers.SCTPChunkTypeHeartbeat,
		layers.SCTPChunkTypeHeartbeatAck,
		layers.SCTPChunkTypeShutdown,
		layers.SCTPChunkTypeShutdownAck,
		layers.SCTPChunkTypeShutdownComplete,
		layers.SCTPChunkType(0xff),
	}

	// We collect all chunks because the decoded chunks should serialise back to the
	// original packet data.
	var buf bytes.Buffer
	for i, chunk := range bundle.Chunks() {
		t.Logf("Chunk #%v: %v", i, FormatChunkHeader(chunk))
		if i >= len(expected) {
			t.Errorf("Unexpected chunk #%v = %v", i, chunk.Type)
			continue
		}
		if chunk.Type != expected[i] {
			t.Errorf("Chunk #%v = %v, want %v", i, chunk.Type, expected[i])
		}

		// We only collect each chunk's content so we can compare to the input data.
		buf.Write(chunk.LayerContents())
	}

	// Once we've collected all chunks as bytes, we may compare with the source bytes
	// for sanity.
	if !bytes.Equal(buf.Bytes(), testBundleData) {
		diff := bytediff.Diff(buf.Bytes(), testBundleData)
		t.Errorf("Concatenated chunk data differs from input (got->want):\n%v", bytediff.BashOutput.String(diff))
	}
}

func BenchmarkChunks(b *testing.B) {
	b.ReportAllocs()
	for b.Loop() {
		for range ChunksFrom(testBundleData) {
			// No need to do anything with the chunks because b.Loop disables all
			// optimisations inside the loop.
		}
	}
}

// This SCTP packet payload contains a predefined byte sequence used for testing
// how this package handles a valid bundle of chunks, according to the IETF
// specification.
//
// This packet was synthesised by concatenating the payloads of several SCTP
// packets. The payload of each packet is annotated by an opening comment
// describing the chunks within. All chunks are properly padded.
var testBundleData = []byte{
	// INIT
	0x01, 0x00, 0x00, 0x24, 0xb6, 0x96, 0xb0, 0x9e, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x0a, 0xff, 0xff,
	0xdb, 0x85, 0x60, 0x23, 0x00, 0x0c, 0x00, 0x06, 0x00, 0x05, 0x00, 0x00, 0x80, 0x00, 0x00, 0x04,
	0xc0, 0x00, 0x00, 0x04,
	// INIT ACK
	0x02, 0x00, 0x01, 0x04, 0x32, 0x80, 0xfb, 0x42, 0x00, 0x00, 0xf4, 0x00, 0x00, 0x0a, 0x00, 0x0a,
	0x85, 0x98, 0xb1, 0x26, 0x00, 0x07, 0x00, 0xe8, 0xd3, 0x08, 0xce, 0xe2, 0x52, 0x95, 0xcc, 0x09,
	0xa1, 0x4c, 0x6f, 0xa7, 0x9e, 0xba, 0x03, 0xa1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0xfb, 0x80, 0x32,
	0x9e, 0xb0, 0x96, 0xb6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x46, 0xc2, 0x50,
	0x00, 0x00, 0x00, 0x00, 0x5e, 0x25, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x0a, 0x00,
	0x26, 0xb1, 0x98, 0x85, 0x02, 0x00, 0x27, 0x0f, 0xac, 0x1d, 0x14, 0x0f, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xb8, 0x22, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x02, 0x00, 0x24, 0x6a, 0x72, 0x5c, 0x1c,
	0x3c, 0xaa, 0x7a, 0xcd, 0xd3, 0x8f, 0x52, 0x78, 0x7c, 0x77, 0xfd, 0x46, 0xbd, 0x72, 0x82, 0xc1,
	0x1f, 0x70, 0x44, 0xcc, 0xc7, 0x9b, 0x9b, 0x7b, 0x13, 0x54, 0x3f, 0x89, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x24,
	0xb6, 0x96, 0xb0, 0x9e, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x0a, 0xff, 0xff, 0xdb, 0x85, 0x60, 0x23,
	0x00, 0x0c, 0x00, 0x06, 0x00, 0x05, 0x00, 0x00, 0x80, 0x00, 0x00, 0x04, 0xc0, 0x00, 0x00, 0x04,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x04,
	0xc0, 0x00, 0x00, 0x04,
	// COOKIE ECHO, DATA
	0x0a, 0x00, 0x00, 0xe8, 0xd3, 0x08, 0xce, 0xe2, 0x52, 0x95, 0xcc, 0x09, 0xa1, 0x4c, 0x6f, 0xa7,
	0x9e, 0xba, 0x03, 0xa1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0xfb, 0x80, 0x32, 0x9e, 0xb0, 0x96, 0xb6,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x46, 0xc2, 0x50, 0x00, 0x00, 0x00, 0x00,
	0x5e, 0x25, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x0a, 0x00, 0x26, 0xb1, 0x98, 0x85,
	0x02, 0x00, 0x27, 0x0f, 0xac, 0x1d, 0x14, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb8, 0x22, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x80, 0x02, 0x00, 0x24, 0x6a, 0x72, 0x5c, 0x1c, 0x3c, 0xaa, 0x7a, 0xcd,
	0xd3, 0x8f, 0x52, 0x78, 0x7c, 0x77, 0xfd, 0x46, 0xbd, 0x72, 0x82, 0xc1, 0x1f, 0x70, 0x44, 0xcc,
	0xc7, 0x9b, 0x9b, 0x7b, 0x13, 0x54, 0x3f, 0x89, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x24, 0xb6, 0x96, 0xb0, 0x9e,
	0x00, 0x01, 0xc0, 0x00, 0x00, 0x0a, 0xff, 0xff, 0xdb, 0x85, 0x60, 0x23, 0x00, 0x0c, 0x00, 0x06,
	0x00, 0x05, 0x00, 0x00, 0x80, 0x00, 0x00, 0x04, 0xc0, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x16, 0xdb, 0x85, 0x60, 0x23,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x6f, 0x6f, 0x21, 0x0a, 0x00, 0x00, 0x00,
	// COOKIE ACK, SACK
	0x0b, 0x00, 0x00, 0x04, 0x03, 0x00, 0x00, 0x10, 0xdb, 0x85, 0x60, 0x23, 0x00, 0x00, 0xf3, 0xfa,
	0x00, 0x00, 0x00, 0x00,
	// DATA
	0x00, 0x03, 0x00, 0x19, 0xdb, 0x85, 0x60, 0x24, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x62, 0x69, 0x7a, 0x7a, 0x6c, 0x65, 0x21, 0x0a, 0x00, 0x00, 0x00, 0x00,
	// SACK
	0x03, 0x00, 0x00, 0x10, 0xdb, 0x85, 0x60, 0x24, 0x00, 0x00, 0xf4, 0x00, 0x00, 0x00, 0x00, 0x00,
	// HEARTBEAT
	0x4, 0x0, 0x0, 0x14, 0x0, 0x1, 0x0, 0x10, 0x0, 0x58, 0xb0, 0x76, 0x0, 0x5, 0x0, 0x8, 0xa, 0x35,
	0x0, 0x19,
	// HEARTBEAT ACK
	0x5, 0x0, 0x0, 0x14, 0x0, 0x1, 0x0, 0x10, 0x0, 0x58, 0xb0, 0x76, 0x0, 0x5, 0x0, 0x8, 0xa, 0x35,
	0x0, 0x19,
	// SHUTDOWN
	0x07, 0x00, 0x00, 0x08, 0x85, 0x98, 0xb1, 0x25,
	// SHUTDOWN ACK
	0x08, 0x00, 0x00, 0x04,
	// SHUTDOWN COMPLETE
	0x0e, 0x00, 0x00, 0x04,
	// UNKNOWN CHUNK (type 255)
	0xff, 0x00, 0x00, 0x10, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
}

func BenchmarkBundleContainer(b *testing.B) {
	b.ReportAllocs()
	for b.Loop() {
		var bundle BundleContainer
		err := bundle.DecodeFromBytes(testBundleData, gopacket.NilDecodeFeedback)
		if err != nil {
			b.Fatal(err)
		}
	}
}
